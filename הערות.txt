שרת- לקוח
הלקוח יוצר קשר ביוזמתו עם השרת, מחליף איתו מפתחות הצפנה
ולאחר מכן מעביר לו את הקובץ המבוקש בתקשורת מוצפנת
הלקוח מוודא שהשרת קיבל את הקובץ 
באופן תקין ע"י השוואת checksum בשני הצדדים, 
במידה ולא עבר באופן תקין, מנסה להעביר שוב )עד 3 
נסיונות. 

השרת ב python
השרת יתמוך בריבוי משתמשים ע"י תהליכונים )threads )או ע"י selector.
גרסת השרת תהיה 3 גרסה זו מופיעה בהודעות תקשורת מטעם השרת.
 השרת יפעל עם חבילת הצפנה Crypto.Cipher
השרת ישמור את נתוני הלקוחות ו הקבצים שנשמרו בזיכרון RAM
בנוסף, הוא יחזיק בסיס נתונים SQLite 
יחזיק תיקיה מקומית שתכלול את הקבצים שיתקבלו מלקוחות
בודק את בסיס הנתונים, אם כבר קיים, וטוען נתוני לקוחות שנרשמו בהפעלות קודמות
ממתין לבקשות מלקוחות בלולאה אין סופית
בעת קבלת בקשה מפענח את הבקשה בהתאם לפרוטוקול:
 השרת יתמוך בריבוי משתמשים ע"י תהליכונים )threads )או ע"י selector.

- בקשה לרישום: במידה ושם המשתמש המבוקש כבר קיים, השרת יחזיר שגיאה. אחרת, השרת 
ייצר UUID חדש עבור המשתמש, ישמור את הנתונים בזיכרון ובבסיס הנתונים ויחזיר תשובת 
הצלחה. 
- מפתח ציבורי מלקוח ייקלט ויעודכן בבסיס הנתונים. בתגובה, ייצור השרת מפתח AES, יצפין 
אותו בעזרת המפתח הציבורי וישלח בחזרה ללקוח.
- הודעה עם קובץ מוצפן: השרת יפענח את הקובץ המוצפן בעזרת מפתח ה-AES המקורי שנשלח 
לאותו לקוח, ויחשב את ה-CRC( שהוא הערך שמתקבל מפעולת checksum). החישוב, בשרת 
ובלקוח, צריך להתבצע באופן זהה לפקודת cksum בלינוקס: 
 /https://www.howtoforge.com/linux-cksum-command
לצורך העניין יסופק קוד לסטודנטים שמבצע את החישוב, ותוכלו להשתמש בו.
- השרת יקבל הודעת הצלחה מהלקוח )CRC אומת( או שליחה חוזרת של הקובץ עד 3 פעמים

שגיאה מצד השרת 
בכל מקרה של שגיאה הלקוח ידפיס למסך הודעה: "error an with responded server "וינסה לשלוח את 
ההודעה שוב, עד 3 פעמים, ואם עדיין לא יצליח, ייצא עם הודעת Fatal מפורטת


לקוח ב C++
תוכנת הלקוח תדע לתקשר מול שרת, להירשם )במידה ולא רשום מהפעלה קודמת(, להחליף איתו מפתחות 
הצפנה ולאחר מכן להעביר אליו באופן מאובטח קובץ מהלקוח שיאוחסן בשרת. הלקוח אינו מתקשר או מודע 
ללקוחות אחרים במערכת.
- הלקוח יפעל על פי סדר פעולות קבוע
-  הלקוח יתבסס על הצפנה בעזרת חבילת C
- גרסת הלקוח תהיה .3
- me.info
-- שורה ראשונה: שם
-- שורה שניה: מזהה ייחודי בייצוג ASCII כאשר כל שני תווים מייצגים ערך hex בעל 8 סיביות.
- -  שורה שלישית: מפתח פרטי שנוצר בריצה הראשונה של התוכנית בפורמט בסיס .





דברים שמחקתי

        if request == "register":  # בקשה לרישום משתמש
            handle_registration(client_socket)
        elif request == "send_public_key":  # בקשה לשליחת מפתח ציבורי
            handle_send_public_key(client_socket)
        elif request == "send_encrypted_file":  # בקשה לשליחת קובץ מוצפן
            handle_send_encrypted_file(client_socket)

        response_data = b"Response to client's request"
        response_length = len(response_data)
        response = struct.pack("<I", response_length) + response_data
        client_socket.send(response)

